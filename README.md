This project is carried out to evaluate the programming method when using the State Machine method instead of simple Polling and Interrupting. Also compare it when using RTOS (FreeRTOS) for past applications.
The main hardware of the project includes I2C SH1106 128x64 OLED module; 4x4 matrix keyboard; LED signaling; Speaker signaling; RFID module RC522. To demo a smart door lock product that uses RFID technology and enters a password to unlock. When the user enters the correct password or scans the authorized card, the OLED will display information and the green LED will turn on. When the user enters the wrong password or scans the wrong card, the OLED will display information and the red LED will turn on; If the user scans incorrectly or enters incorrectly more than 3 times, the speaker will sound an alarm for 5 seconds.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The system has 3 main states: IDLE_State; RFID_State and KEY_State. You can see the detailed State Machine diagram in the image RFED_StateMachine.png. Below is a description of how they work:
- IDLE_State: This state is the system's default state, the OLED screen will display the Ho Chi Minh City University of Technology logo and welcome message. Also check to see if there is an event of pressing the key pad or swiping the card to change the state to KEY_State or RFID_State.
- RFID_State: Status of card scanning event processing when a card is scanned. When entering this state, the systick timer will start counting (the systick is configured to interrupt after 1ms). When the systickCounter counts to 3000 (3 seconds) without any further card scanning events occurring, the system will switch IDLE_State again. If there is a card scanning event before the time the systickCounter reaches 3000, the systickCounter will be reset to 0 and continue counting up. In addition, when there is a button press event, the system state also changes to Keypad_State.
- KEY_State: Status of handling the event of entering a password from the key pad. When entering this state, similarly, the systick timer will start counting and when the systickCounter reaches the value 3000 (3s) without any key press events during that time, the system will return to the IDLE_State state. If there is a button press event before the time the systickCounter reaches 3000, the systickCounter will be reset to 0 and continue counting up. In addition, when there is a card scanning event while entering the key, the system's state also changes to RFID_State and reacts immediately.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

*Final comment on State Machine: Polling is a simple and easy-to-implement method but consumes CPU resources due to continuous checking of states, causing energy waste, especially in battery-powered systems. Interrupts overcome this drawback by only triggering processing when an event occurs, which saves resources but can be complicated if processing many events simultaneously. State Machine provides a clear and easy-to-maintain logical organization, suitable for systems with sequential or complex flow of operations. Meanwhile, RTOS excels when the system requires managing multiple tasks at the same time (such as Bluetooth communication, input processing, or power management), thanks to its preemptive scheduling and real-time response capabilities. , although more complex to implement. The optimal choice depends on the complexity and performance requirements of the system.
Using State Machine with interrupts provides advantages in resource efficiency and logic simplification for small systems such as smart locks, allowing interrupt events to be handled quickly without the need for an operating system. However, as the system becomes more complex, managing overlapping states and events becomes difficult, and true multi-tasking is not supported. In contrast, RTOS such as FreeRTOS provide a more flexible platform, supporting multi-tasking and prioritization management, suitable for complex systems or scaling requirements, but consume more resources and require In-depth knowledge for implementation.
You can refer to my project using both State Machine and RTOS (FreeRTOS) methods to design and develop smart gardens at the repository called SmartGraden.
